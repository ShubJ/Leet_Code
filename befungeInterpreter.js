// Esoteric languages are pretty hard to program, but it's fairly interesting to write interpreters for them!

// Your task is to write a method which will interpret Befunge-93 code! Befunge-93 is a language in which the code is presented not as a series of instructions, but as instructions scattered on a 2D plane; your pointer starts at the top-left corner and defaults to moving right through the code. Note that the instruction pointer wraps around the screen! There is a singular stack which we will assume is unbounded and only contain integers. While Befunge-93 code is supposed to be restricted to 80x25, you need not be concerned with code size. Befunge-93 supports the following instructions (from Wikipedia):

// 0-9 Push this number onto the stack.
// + Addition: Pop a and b, then push a+b.
// - Subtraction: Pop a and b, then push b-a.
// * Multiplication: Pop a and b, then push a*b.
// / Integer division: Pop a and b, then push b/a, rounded down. If a is zero, push zero.
// % Modulo: Pop a and b, then push the b%a. If a is zero, push zero.
// ! Logical NOT: Pop a value. If the value is zero, push 1; otherwise, push zero.
// ` (backtick) Greater than: Pop a and b, then push 1 if b>a, otherwise push zero.
// > Start moving right.
// < Start moving left.
// ^ Start moving up.
// v Start moving down.
// ? Start moving in a random cardinal direction.
// _ Pop a value; move right if value = 0, left otherwise.
// | Pop a value; move down if value = 0, up otherwise.
// " Start string mode: push each character's ASCII value all the way up to the next ".
// : Duplicate value on top of the stack. If there is nothing on top of the stack, push a 0.
// \ Swap two values on top of the stack. If there is only one value, pretend there is an extra 0 on bottom of the stack.
// $ Pop value from the stack and discard it.
// . Pop value and output as an integer.
// , Pop value and output the ASCII character represented by the integer code that is stored in the value.
// # Trampoline: Skip next cell.
// p A "put" call (a way to store a value for later use). Pop y, x and v, then change the character at the position (x,y) in the program to the character with ASCII value v.
// g A "get" call (a way to retrieve data in storage). Pop y and x, then push ASCII value of the character at that position in the program.
// @ End program.
// (i.e. a space) No-op. Does nothing.
// The above list is slightly modified: you'll notice if you look at the Wikipedia page that we do not use the user input instructions and dividing by zero simply yields zero.

// Here's an example:

// >987v>.v
// v456<  :
// >321 ^ _@
// will create the output 123456789.

// So what you must do is create a function such that when you pass in the Befunge code, the function returns the output that would be generated by the code. So, for example:

// "123456789".equals(new BefungeInterpreter().interpret(">987v>.v\nv456<  :\n>321 ^ _@")
// This test case will be added for you.

function interpret(code) {
  let output = "";
  var stack = [];
  const input = code.split("\n").map((row) => row.split(""));
  let x = 0,
    y = 0;
  let dir = "right";
  while (input[x][y] != "@") {
    let currAction = input[x][y];

    if (currAction == ">" && input[x][y + 1]) dir = "right";
    if (currAction == "^" && input[x - 1]) dir = "up";
    if (currAction == "<" && input[x][y - 1]) dir = "left";
    if (currAction == "v" && input[x + 1][y]) dir = "down";

    if (!!parseInt(currAction) || (currAction == 0 && currAction != " "))
      stack.push(parseInt(currAction));
    if (currAction == "+") {
      let a = stack.pop();
      let b = stack.pop();
      stack.push(parseInt(a + b));
    }
    if (currAction == "-") {
      let a = stack.pop();
      let b = stack.pop();
      stack.push(parseInt(b - a));
    }
    if (currAction == "*") {
      let a = stack.pop();
      let b = stack.pop();
      stack.push(parseInt(a * b));
    }
    if (currAction == "/") {
      let a = stack.pop();
      if (a == 0) stack.push(0);
      else {
        let b = stack.pop();
        stack.push(parseInt(b / a));
      }
    }
    if (currAction == "%") {
      let a = stack.pop();
      if (a == 0) stack.push(0);
      else {
        let b = stack.pop();
        stack.push(parseInt(b % a));
      }
    }
    if (currAction == "!") {
      let a = stack.pop();
      stack.push(a == 0 ? 1 : 0);
    }
    if (currAction == "`") {
      let a = stack.pop();
      let b = stack.pop();
      stack.push(b > a ? 1 : 0);
    }
    if (currAction == "_") {
      let a = stack.pop();
      dir = a == 0 ? "right" : "left";
    }
    if (currAction == "|") {
      let a = stack.pop();
      dir = a == 0 ? "down" : "up";
    }
    if (currAction == '"') {
      // " Start string mode: push each character's ASCII value all the way up to the next "
      if (dir == "up") x = x - 1;
      if (dir == "right") y++;
      if (dir == "down") x++;
      if (dir == "left") y = y - 1;
      let tempCurrentAction = input[x][y];
      while (tempCurrentAction != '"') {
        stack.push(input[x][y].charCodeAt());
        if (dir == "up") x = x - 1;
        if (dir == "right") y++;
        if (dir == "down") x++;
        if (dir == "left") y = y - 1;
        tempCurrentAction = input[x][y];
      }
    }
    if (currAction == ":") {
      let a = stack.pop();
      if (a) stack.push(...[a, a]);
      else stack.push(0);
    }
    if (currAction == "\\") {
      let a = stack.pop();
      let b = stack.pop();
      if (b) stack.push(...[a, b]);
      else stack.push(...[a, 0]);
    }
    if (currAction == "$") {
      stack.pop();
    }
    if (currAction == ".") {
      let a = stack.pop();
      output += a;
    }
    if (currAction == ",") {
      let a = stack.pop();
      output += String.fromCharCode(a);
    }
    if (currAction == "p") {
      let y = stack.pop();
      let x = stack.pop();
      let v = stack.pop();
      input[x][y] = String.fromCharCode(v);
    }
    if (currAction == "g") {
      let y = stack.pop();
      let x = stack.pop();
      stack.push(input[x][y].toString().charCodeAt());
    }
    if (currAction == "#") {
      if (dir == "up") x = x - 1;
      if (dir == "right") y++;
      if (dir == "down") x++;
      if (dir == "left") y = y - 1;
    }

    if (currAction == "?") {
      let dirArray = ["up", "down", "right", "left"];
      dir = dirArray[Math.floor(Math.random() * dirArray.length)];
    }
    if (dir == "up") x = x - 1;
    if (dir == "right") y++;
    if (dir == "down") x++;
    if (dir == "left") y = y - 1;
    // console.log(stack);
  }
  console.log(stack);
  console.log(output);
  return output;
}
//  0 8
// interpret(">987v>.v\nv456<  :\n>321 ^ _@");
interpret(`08>:1-:v v *_.@ \n  ^    _$>\\:^`);

// >>>> Proper Solution

// function interpret(code) {
//   code = code.split("\n").map((row) => row.split(""));
//   var output = "",
//     stack = [],
//     i = 0,
//     j = 0,
//     ch = code[0][0],
//     dirs = [
//       [0, 1],
//       [0, -1],
//       [-1, 0],
//       [1, 0],
//     ],
//     dir = dirs[0];
//   var next = () => {
//     i = (i + dir[0] + code.length) % code.length;
//     j = (j + dir[1] + code[i].length) % code[i].length;
//     return code[i][j];
//   };
//   while (ch !== "@") {
//     if (/[0-9]/.test(ch)) stack.push(+ch);
//     if (/[\+\-\*%]/.test(ch)) {
//       var a = stack.pop(),
//         b = stack.pop();
//       stack.push(eval("b" + ch + "a"));
//     }
//     if ("/" == ch) {
//       var a = stack.pop(),
//         b = stack.pop();
//       stack.push(a ? (b / a) >> 0 : 0);
//     }
//     if ("!" == ch) stack.push(stack.pop() ? 0 : 1);
//     if ("`" == ch) {
//       var a = stack.pop(),
//         b = stack.pop();
//       stack.push(b > a ? 1 : 0);
//     }
//     if (">" == ch) dir = [0, 1];
//     if ("<" == ch) dir = [0, -1];
//     if ("^" == ch) dir = [-1, 0];
//     if ("v" == ch) dir = [1, 0];
//     if ("?" == ch) dir = dirs[(Math.random() * 4) >> 0];
//     if ("_" == ch) dir = stack.pop() == 0 ? [0, 1] : [0, -1];
//     if ("|" == ch) dir = stack.pop() == 0 ? [1, 0] : [-1, 0];
//     if (":" == ch) {
//       var a = stack.pop() || 0;
//       stack.push(a, a);
//     }
//     if ("\\" == ch) {
//       var a = stack.pop(),
//         b = stack.pop() || 0;
//       stack.push(a, b);
//     }
//     if ("$" == ch) stack.pop();
//     if ("." == ch) output += stack.pop();
//     if ("," == ch) output += String.fromCharCode(stack.pop());
//     if ("p" == ch) {
//       var y = stack.pop(),
//         x = stack.pop();
//       code[y][x] = String.fromCharCode(stack.pop());
//     }
//     if ("g" == ch) {
//       var y = stack.pop(),
//         x = stack.pop();
//       stack.push(code[y][x].charCodeAt(0));
//     }

//     if ('"' == ch) while ((ch = next()) !== '"') stack.push(ch.charCodeAt(0));
//     if ("#" == ch) ch = next();
//     ch = next();
//   }
//   console.log(output);
//   return output;
// }

// var UP = [-1, 0],
//   DOWN = [1, 0],
//   LEFT = [0, -1],
//   RIGHT = [0, 1];

// function interpret(code) {
//   var grid = extractGrid(code),
//     row = 0,
//     col = 0,
//     direction = RIGHT,
//     stringMode = false,
//     stack = [],
//     output = "";

//   while (true) {
//     var instr = grid[row][col];

//     if (stringMode && instr !== '"') {
//       stack.pushNumber(instr.charCodeAt(0));
//     } else if (/[0-9]/.test(instr)) {
//       stack.pushNumber(instr);
//     } else {
//       switch (instr) {
//         case "+":
//           stack.pushNumber(stack.pop() + stack.pop());
//           break;
//         case "-":
//           stack.pushNumber(stack.skipPop() - stack.pop());
//           break;
//         case "*":
//           stack.pushNumber(stack.pop() * stack.pop());
//           break;
//         case "/":
//           stack.pushNumber(stack.skipPop() / stack.pop());
//           break;
//         case "%":
//           stack.pushNumber(stack.skipPop() % stack.pop());
//           break;
//         case "!":
//           stack.pushNumber(stack.pop() ? 0 : 1);
//           break;
//         case "`":
//           stack.pushNumber(stack.skipPop() > stack.pop() ? 1 : 0);
//           break;
//         case ">":
//           direction = [0, 1];
//           break;
//         case "<":
//           direction = [0, -1];
//           break;
//         case "^":
//           direction = [-1, 0];
//           break;
//         case "v":
//           direction = [1, 0];
//           break;
//         case "?":
//           direction = [UP, DOWN, LEFT, RIGHT][Math.floor(Math.random() * 4)];
//           break;
//         case "_":
//           direction = stack.pop() ? LEFT : RIGHT;
//           break;
//         case "|":
//           direction = stack.pop() ? UP : DOWN;
//           break;
//         case '"':
//           stringMode = !stringMode;
//           break;
//         case ":":
//           stack.pushNumber(stack.peek() ? stack.peek() : 0);
//           break;
//         case "\\":
//           stack.pushNumber(stack.skipPop());
//           break;
//         case "$":
//           stack.pop();
//           break;
//         case ".":
//           output += stack.pop();
//           break;
//         case ",":
//           output += String.fromCharCode(stack.pop());
//           break;
//         case "#":
//           advance();
//           break;
//         case "p":
//           grid[stack.pop()][stack.pop()] = String.fromCharCode(stack.pop());
//           break;
//         case "g":
//           stack.pushNumber(grid[stack.pop()][stack.pop()].charCodeAt(0));
//           break;
//         case "@":
//           return output;
//         case " ":
//           break;
//         default:
//           throw new Error(
//             "Unknown instruction: " + instr.charCodeAt(0) + ' ("' + instr + '")'
//           );
//       }
//     }

//     advance();
//   }

//   function advance() {
//     row += direction[0];
//     col += direction[1];

//     if (row < 0) {
//       row = grid.length - 1;
//     } else if (row >= grid.length) {
//       row = 0;
//     }

//     if (col < 0) {
//       col = grid[row].length - 1;
//     } else if (col >= grid[row].length) {
//       col = 0;
//     }
//   }
// }

// Array.prototype.pushNumber = function (n) {
//   if (typeof n === "string") n = parseInt(n, 10);
//   if (!Number.isFinite(n)) n = 0;
//   this.push(Math.floor(n));
// };

// Array.prototype.skipPop = function () {
//   return this.length > 1 && this.splice(this.length - 2, 1)[0];
// };

// Array.prototype.peek = function () {
//   return this[this.length - 1];
// };

// function extractGrid(codeString) {
//   return codeString.split("\n").map(function (line) {
//     return line.split("");
//   });
// }
// console.log(interpret(`08>:1-:v v *_.@ \n  ^    _$>\:^`));
